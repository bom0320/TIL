상태값 자체는 함수가 아니다
===

## `useState`는 두 가지를 반환한다:
### 1. 상태값(state) 
- 컴포넌트가 관리하는 데이터
- 이것은 **함수가 아닌 일반 값**이다. 즉, `useState` 를 사용해 상태값으로 숫자, 문자열, 객체 등 다양한 데이터를 저장할 수 있다.

### 2. 상태를 업데이트하는 함수
- 상태를 변경하는 함수이다.
- 이 함수는 상태 값을 업데이트하는 데 사용된다. 이 부분이 함수이다.


#### 예시로 다시 살펴보자:
```js
const [count,setCount] = useState(0);
```
- **`count`**는 현재 **상태값**이다. 여기서 `count` 는 숫자 0 으로 초기화되어 있다. 이 **상태값은 함수가 아니다.** 그냥 숫자(데이터)이다.
- **`setCount`**는 **상태를 업데이트하는 함수**이다. 이 함수는 새로운 상태값을 받아서 `count` 값을 변경한다.

### 그럼 왜 카운터 코드에서 함수처럼 보일까?
```js
<button onClick= {() => setCount((prev) => prev + 1 )}>+</button>
```
여기서 혼동이 생길 수 있는 부분은 **상태를 업데이트하는 함수 `setCount`**가 **함수 형태의 인수를 받는 경우**이다.

`setCount((prev) => prev + 1)` 는 **이전 상태값(`prev`)** 을 받아서 새로운 상태 값을 계산하는 함수이다. 이 **인수로 전달될 함수** 가 이전 상태값을 바탕으로 새로운 값을 반환하는 것일 뿐, **상태값 자체가 함수는 아니다.**

### 다시 요약:
- `count` 는 **숫자** 또는 **데이터 값**으로, **함수가 아니다.**
- `setCount` 는 **상태를 업데이트하는 함수**이다. 
- `setCount((prev) => prev + 1)`는 **상태값을 업데이트할 때 이전 상태를 이용하는 방법**이다. 여기서 `prev => prev + 1` 은 **업데이트 함수의 인수로 사용된 콜백 함수** 일뿐, 상태값인 `count` 자체는 함수가 아니다.

이 부분이 헷갈릴 수 있지만, **상태값 자체는 함수가 아니고,** 상태를 변경할 때 함수형 업데이트패턴을 사용하면 함수처럼 보일 수 있는 것이다.