Vacation Study
===


안녕하세요! 8기 FrontEnd 전공에 대해서 공부하고 있는 김봄이라고 합니다!

저는 이번 방학 때 React 를 집중적으로 학습했는데요.  오늘은 리액트를 공부하면서 거쳐온 과정에 관해 이야기해보려고 합니다.

## 리액트를 알게 된 계기

프론트엔드를 공부하면서 프레임워크와 라이브러리에 대해 알게 되었는데요. 프레임워크는 간단히 말해 애플리케이션 개발 시 필수적인 코드와 알고리즘 등의 기능을 위한 구조를 제공하고, 라이브러리는 개발에 필요한 기능을 미리 구현해 놓은 도구를 말합니다. 그중에서도 프론트엔드 개발에서 가장 유명한 자바스크립트 라이브러리인 React에 관심을 가지게 되면서 공부를 시작하게 되었습니다.

## 리액트를 알아가는 과정

리액트를 공부한지는 고작 2주였는데요. 리엑트의 ㄹ 자도 못한 것 같지만 어찌저찌 이번 방학동안, 카운터와 todoList, 토익까지는 만들어보았습니다. 

### 초보자를 위한 리액트 강좌-코딩앙마

![](https://i.ytimg.com/vi/DuJC2ATdGtw/hq720.jpg?sqp=-oaymwEhCK4FEIIDSFryq4qpAxMIARUAAAAAGAElAADIQj0AgKJD&rs=AOn4CLBTPQiBtAM2GlGttNQsbYNAm8ajKg)

맨 처음에 React를 공부하기 위해 켰던 것은 동영상 강의였습니다. 이 강의는 제가 선배들과 프로젝트를 진행하면서 멘토 선배가 추천해주신 강의였는데요. 이강의는 3년 전 강의이다보니, 일부 내용이 최신 정보와 맞지 않아 도태된 부분이 존재했습니다. 하지만 다행이도 멘토 선배가 계속해서 최신 정보로 업데이트해 주셔서 많은 도움이 된 것 같습니다. 

## 파일, 폴더 생성 및 역할

React 를 공부하기 앞서 React 애플리케이션을 생성해야하는데요. 저는 React 애플리케이션을 생성하기 위해서 

```bash
npx create-react-app .
```

라는 명령어를 적었습니다. 이 명령어는 필요한 패키지를 설치하고, 개발 환경을 자동으로 구성할 수 있는 등의 역할을 수행할 수 있습니다. 추가로  이 명령어 끝에 ‘ . ’을 붙이면 현재 위치한 디렉터리에 React 프로젝트를 생성해라라는 말이 됩니다.  

마지막으로, 터미널에 **npm start** 이라고 적으면 즉시 개발서버가 시작되어 애플리케이션 브라우저에서 확인할 수 있습니다. 

# 카운터

본격적인 토익을 만들기 이전, React의 상태(state)와 상태 관리의 개념을 이해하기 위해 카운터를 만들어봤었는데요.

```jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Counter: {count}</h1>
      <button onClick={() => setCount((prev) => prev + 1)}>+</button>
      <button onClick={() => setCount((prev) => prev - 1)}>-</button>
    </div>
  );
}

export default Counter;

```

간단한 카운터를 만드는건데도 불구하고 이 코드에는 useState, callback 등등.. 정말 많은 개념이 들어가 있었습니다. 

## useState

이 함수형 컴포넌트에 대해 알아가기 앞서 React Hook 에 대해서 알고있어야했었는데요. 

React Hook 이란 간단히 말해서 함수형 컴포넌트(React에서 컴포넌트를 정의하는 두 가지 주요 방법)에서 상태 관리와 생명 주기 생명주기 메서드를 사용할 수 있게 해주는 훅입니다. 

대표적인 훅으로는 상태 관리를 위한 useState, 컴포넌트 생명 주기를 다루는 useEffect 가 있습니다.

따라서 이 코드부분은

```jsx
const [count, setCount] = useState(0);
```

현재 상태값 count 를 0 으로 초기화 하고 그 값을 변경할 수 있는 setCount 함수를 생성한 게 됩니다. 따라서 count 라는 상태를 관리해주기 위해서 useState 훅을 사용한게 되죠

## Callback

콜백은 비동기 작업이 완료되었을 때 실행되도록 예약되는 함수라고 할 수 있습니다. 

여기 Count 컴포넌트에서 사용된 콜백 함수는 setCount를 통해 count 의 값을 업데이트하기 위해 사용됩니다. 콜백 함수는 React 를 공부하다보면 어쩔 수 없이 마주할 수 밖에 없는 함수들중 일부인데 이런 콜백 함수는 특히 상태 업데이트가 이전 상태에 의존할 때 매우 유용합니다. 

카운트 코드 일부를 살펴보면

```jsx
setCount((prev) => prev + 1);
```

이 경우, setCount 에 전달된 콜백 함수는 prev 라는 인수를 받습니다. prev 는 상태의 이전 값이라는 뜻으로 이 콜백 함수는 prev 값을 기반으로 새 상태 값을 계산하여 반환합니다.  

### 왜 콜백을 사용하는지

코드를 작성하다보면 여러 상태 업데이트가 거의 동시에 발생할 때, 이전 상태 값을 기반으로 상태를 변경해야 하는 경우가 많습니다. 이때 콜백 함수를 사용하면 이전 상태에 의존하여 새로운 상태를 계산할 수 있습니다.

즉, 콜백은 **비동기 작업을 수행할 수 있는 중요한 도구**라고 할 수 있습니다.

```jsx
<button onClick={() => setCount((prev) => prev + 1)}>+</button>

// 버튼 클릭 시, count 상태 증가시키는 역할을 함 
```

따라서 이 코드는 버튼을 클릭할 때마다 count 값을 1씩 증가 시키는 기능을 구현하는게 됩니다.

# 토익

토익 웹페이지를 만들어보면서 axios, useparams 등등.. 되게 여러가지의 개념에 대해서 공부를 해야했지만, 그중 제일 헷갈렸고 제 발목을 잡았던 props 에 대해서 설명해보겠습니다. 

## Props 의 이해

어떻게 보면 React 의 기본중에 기본이 헷갈렸던 것 같은데요..  props 에 대해 자세히 이야기하기 앞서, Props 와 State 는 속성과 상태를 나타내고, 리액트 컴포넌트에서 데이터를 관리하는 두 가지 주요 개념이라는 것은 알고 있으실텐데요. 

전 단순히 props 가 부모 컴포넌트가 자식 컴포넌트로 전달되는 모든 데이터로만 알고 있었습니다.(정확하게 props 가 뭘 하는지는 와닫지 않았던것..)

밑에 코드는 props 를 설명하기 위한 참고자료로만 봐주시면 될 것 같습니다.

**Day.jsx : 부모 컴포넌트**

```jsx
{wordList.map((word) => (
   <Word key={word.id} word={word} />
    // 'word={word}' 는 props 로 word 데이터를 전달한다는것 의미
))}
```

**Word.jsx : 자식 컴포넌트**

```jsx
const Word = ({ word }) => {
  // word => props.word
```

그래서 토익 코드의 일부분인 이 부분에서 부모 컴포넌트와 자식 컴포넌트를 구분하는것과, 그들의 관계가 헷갈리기 시작했습니다. 그래서 이 코드를 이해하기 위해 시간을 많이 할애하게 된 것 같습니다.

## 부모 컴포넌트와 자식 컴포넌트의 관계

먼저 props를 이해하기 위해서는 부모 컴포넌트와 자식 컴포넌트의 관계에 대해서 이해를 해야하는데요.

### 부모 컴포넌트

- 자식컴포넌트를 **포함**(자신의 JSX 내부에)하고, 데이터를 전달하는 역할을 함

### 자식 컴포넌트

- 부모 컴포넌트로부터 전달받은 **데이터를 사용**하여 화면을 랜더링


# 전체 흐름

**Day.jsx : 부모 컴포넌트**

```jsx
{wordList.map((word) => (
   <Word key={word.id} word={word} />
    // 'word={word}' 는 props 로 word 데이터를 전달한다는것 의미
))}
```

### **1. map 함수의 매개변수 `word` :**

- wordList 배열의 각 요소(객체) 가 map 함수의 매개변수 `word` 로 전달됨
    
    ex) { id: 1, eng: "Hello", kor: "안녕하세요", isDone: false } 같은 객체
    
    ⇒ 이 `word` 객체가 **Word 컴포넌트의 props 로 전달**됨
    

### **2. word={word}**

이 구문은 부모 컴포넌트가 자식 컴포넌트로 props 를 전달할 때, 

```jsx
<Word key={word.id} word={word} /> 
```

- **word:**  props 객체의 속성 이름(key) → props. name
- **{ word } :**  map 함수의 매개변수 word 는 props.value( props의 속성값) 이 됩니다.

즉, word={word} 는 

```jsx
props.word={props.value}
```

이것과 같은 형식⇒ 이 값을 자식 컴포넌트로 전달

이런 **속성 이름**과 **속성값**을 명시함으로서, 자식 컴포넌트는 전달받은 props 객체에서 특정 속성을 구조 분해 할당을 통해 추출할 수 있습니다.

- 구조 분해 할당은 객체의 키(속성 이름) 을 기준으로 작동하므로, 부모 컴포넌트가 전달한 속성 이름알고 있어야 함!!!

따라서, 부모 컴포넌트가 `word` 라는 이름의 속성을 전달한다는 것을 알고 있기 때문에 자식 컴포넌트에서 **‘ ({  word }) ’** 로 그 속성을 바로 변수로 사용할 수 있습니다.

### 3. 자식 컴포넌트에서 props 받기

- 자식 컴포넌트 Word 는 props 객체를 통해 전달받은 word 속성을 구조 분해 할당을 통해 직접 변수로 받아 사용하는데요.

```jsx
const Word = ({ word }) => {}
// word => props.word
```

props.word 를 구조 분해 할당으로 받아서 word 라는 변수로 간단히 받아  사용할 수 있습니다.

```jsx
{wordList.map((word) => (
   <Word key={word.id} word={word} />
    // 'word={word}' 는 props 로 word 데이터를 전달한다는것 의미
))}
```

즉, 이 부분은 `word` 라는 이름을 가진 props(즉, 이건 [props.name](http://props.name) 이 되는거) 에 map 함수로 순회된 wordList 배열의 각 요소가 포함됩니다.

저는 이런식으로 코드를 작성해보면서 React에서 부모와 자식 컴포넌트 간의 데이터를 주고받는 것을 이해하려고 노력했습니다.

### 만약 구조분해 할당을 사용하지 않는다면

> **구조분해란?**
객체나 배열에서 특정 속성이나 요소를 쉽게 꺼내서 변수로 사용할 수 있게 해주는 JavaScript 문법
> 

만약 구조 분해 할당을 사용하지 않으면, 자식 컴포넌트에서 props 객체에 직접 접근해야 하기 때문에 코드가 다소 복잡하고 길어질 수 있습니다. 이를 예시를 통해 살펴봅시다.

**구조 분해 할당 사용**

```jsx
const Word = ({ word }) => {
  return (
    <tr>
      <td>{word.eng}</td>
      <td>{word.kor}</td>
      <td>{word.isDone ? "Done" : "Not Done"}</td>
    </tr>
  );
};
```

- 간단하고 명확한 코드로, word 변수만 사용

**구조 분해 할당 미사용**

```jsx
const Word = (props) => {
  return (
    <tr>
      <td>{props.word.eng}</td>
      <td>{props.word.kor}</td>
      <td>{props.word.isDone ? "Done" : "Not Done"}</td>
    </tr>
  );
};

```

- props 객체를 매번 참조해야하므로 코드가 복잡해짐

**결론**

구조 분해 할당을 사용하면:

- 코드가 더 간결해지고,
- 가독성이 좋아지며,
- 유지보수가 용이해진다.

반대로, 구조 분해 할당을 사용하지 않으면 코드가 더 길고 복잡해질 수 있습니다. 특히 여러 `props`를 사용할 때 그 차이가 더욱 두드러집니다.

## 총평과 느낀점

이번 2주동안 React 에 대해 공부를 하면서 총평은 저는 정말 배워야할 게 많다는 것이였습니다.  멘토 선배가 꾸준히 멘토링을 해주시고, 계속해서 새로운 개념을 배웠지만, 역시나 기본이 가장 중요한 것 같다는 생각을 했습니다. 토익 웹페이지를 만들면서도, 카운터를 만들면서도 useState 를 계속해서 마주하게 되는데 이때 가장 먼저 겪게 되는 것이  배열 디스트럭처링 문법이라고 생각했습니다. 저는 이 문법을 이해하기 위해 많은 시간을 할애한 것 같습니다.. 

기초가 없을 때 배웠을 때는 이 문법이 익숙지 않아서 기억하기도 힘들었고 조금만 오류가 나도 어디서 오류가 났는지 원인을 파악하기도 힘들었습니다. 그리고 응용하는 것 자체가 너무 힘들었었습니다. 하지만 React 를 공부하다 보면 자바스크립트에 대해서도 공부하게 되는데 자바스크립트와 React 공부를 병행하다보니 이러한 문제에 관해서 상당부분이 해결되었던 것 같습니다. 동시에 두 개념이 뒤죽박죽 되지 않도록 개념을 확실히 잡고 넘어가야겠다는 경각심 또한 가지게 되었습니다. 리액트를 공부하다보면 배워야할 것들이 정말 많지만  이 처음의 고개만 잘 뛰어넘으면 리액트의 세상에서 마음껏 즐겁게 뛰놀 수 있는 날이 올 수 있을 것으로 생각합니다.